// background.js (MV3 service worker)

// ---------------------------
// Constants & helpers
// ---------------------------
const CACHE_PREFIX = "repoCache:";
const CACHE_TTL_MS = 1000 * 60 * 60 * 24;   // 24h for normal entries
const RATE_TTL_MS  = 1000 * 60 * 60 * 2;    // 2h for rate-limited entries
const CONFIG_KEY   = "repoCheckerConfig";   // unify on the same key used by popup.js

chrome.runtime.onInstalled.addListener(() => {
  console.log("GitPulse Installed");
});

// Storage helpers
const getLocal = (keys) =>
  new Promise((resolve) => chrome.storage.local.get(keys, resolve));
const setLocal = (obj) =>
  new Promise((resolve) => chrome.storage.local.set(obj, resolve));
const removeLocal = (keys) =>
  new Promise((resolve) => chrome.storage.local.remove(keys, resolve));

// Small utils
const now = () => Date.now();
const withinDays = (dateStr, maxDays) => {
  if (!dateStr || !Number.isFinite(maxDays)) return true;
  const last = new Date(dateStr);
  const cutoff = new Date();
  cutoff.setDate(cutoff.getDate() - maxDays);
  return last >= cutoff;
};
const isString = (x) => typeof x === "string";

// Merge active, enabled config fields into a flat rules object
async function loadActiveRules() {
  const { [CONFIG_KEY]: cfg } = await getLocal([CONFIG_KEY]);
  if (!cfg) return {};
  return Object.entries(cfg)
    .filter(([, f]) => f && f.active && f.value !== undefined)
    .reduce((acc, [k, f]) => { acc[k] = f.value; return acc; }, {});
}

// Cache helpers
async function readCache(key) {
  const full = CACHE_PREFIX + key;
  const item = (await getLocal([full]))[full];
  if (!item) return null;

  const age = now() - (item.checkedAt || 0);
  const ttl = item.isActive === "rate_limited" ? RATE_TTL_MS : CACHE_TTL_MS;
  if (age < ttl) return item;
  return null;
}
async function writeCache(key, value) {
  const full = CACHE_PREFIX + key;
  return setLocal({ [full]: { ...value, checkedAt: now() } });
}
async function clearCache() {
  const all = await getLocal(null);
  const keys = Object.keys(all).filter((k) => k.startsWith(CACHE_PREFIX));
  if (keys.length) await removeLocal(keys);
  return { success: true };
}

// Read PAT only in background
async function getPAT() {
  const { githubPAT } = await getLocal(["githubPAT"]);
  return githubPAT || "";
}

// ---------------------------
// Host-specific fetchers
//   (Add more hosts here and return { status, details? })
// ---------------------------
async function fetchGithubRepoStatus({ owner, repo }, pat, rules) {
  const headers = {
    Accept: "application/vnd.github.v3+json",
    ...(pat ? { Authorization: `token ${pat}` } : {}),
  };

  // 1) repo metadata
  const repoRes = await fetch(`https://api.github.com/repos/${owner}/${repo}`, { headers });
  if (repoRes.status === 403) return { status: "rate_limited" };
  if (!repoRes.ok) throw new Error(`GitHub repo API failed: ${repoRes.status}`);
  const repoData = await repoRes.json();

  // Optional rule: require not archived
  const isArchivedOk = (rules.require_not_archived === undefined)
    ? true
    : !repoData.archived;

  // 2) Open PR threshold (use search API for total_count)
  let openPrsOk = true;
  if (Number.isFinite(rules.open_prs_max)) {
    const prsRes = await fetch(
      `https://api.github.com/search/issues?q=repo:${owner}/${repo}+is:pr+is:open&per_page=1`,
      { headers }
    );
    if (prsRes.status === 403) return { status: "rate_limited" };
    if (!prsRes.ok) throw new Error(`GitHub search PRs failed: ${prsRes.status}`);
    const prs = await prsRes.json();
    openPrsOk = (prs.total_count || 0) <= rules.open_prs_max;
  }

  // 3) Last closed PR age
  let lastClosedPrOk = true;
  if (Number.isFinite(rules.last_closed_pr_max_days)) {
    const closedRes = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/pulls?state=closed&sort=updated&direction=desc&per_page=1`,
      { headers }
    );
    if (closedRes.status === 403) return { status: "rate_limited" };
    if (!closedRes.ok) throw new Error(`GitHub closed PRs failed: ${closedRes.status}`);
    const closed = await closedRes.json();
    const lastClosed = closed?.[0]?.closed_at || closed?.[0]?.merged_at;
    lastClosedPrOk = withinDays(lastClosed, rules.last_closed_pr_max_days);
  }

  // 4) Core push recency
  const pushOk = withinDays(
    repoData.pushed_at,
    Number.isFinite(rules.max_repo_update_time) ? rules.max_repo_update_time : 365
  );

  const isActive = isArchivedOk && openPrsOk && lastClosedPrOk && pushOk;
  return {
    status: isActive ? true : false,
    details: { pushOk, isArchivedOk, openPrsOk, lastClosedPrOk }
  };
}

// Add other ecosystems here as needed (GitLab, Bitbucket, npm, PyPI, crates, Packagist, DockerHub, etc.)

async function fetchRepoStatusByUrl(rawUrl, rules) {
  const { hostname, pathname } = new URL(rawUrl);
  const parts = pathname.split("/").filter(Boolean);
  const pat = await getPAT();

  switch (hostname) {
    case "github.com": {
      if (parts.length < 2) throw new Error("Invalid GitHub URL");
      const [owner, repo] = parts;
      return fetchGithubRepoStatus({ owner, repo }, pat, rules);
    }
    // TODO: handle other hosts similar to GitHub and return {status, details}
    default:
      // No integration → assume active to avoid blocking
      return { status: true };
  }
}

// ---------------------------
// Message router (single listener)
// ---------------------------
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  (async () => {
    try {
      switch (message?.action) {
        case "open-url": {
          // MV3: no alert() — return an error if no active tab
          const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
          if (!tabs || !tabs.length || !tabs[0].url) {
            sendResponse({ ok: false, error: "No active tab URL available" });
            return;
          }
          // If you intended to open a specific URL, do it here with chrome.tabs.create
          sendResponse({ ok: true });
          return;
        }

        case "getCache": {
          const key = isString(message.key) ? message.key : "";
          const item = key ? await readCache(key) : null;
          if (item) {
            console.log(`[Cache] HIT for ${CACHE_PREFIX + key}`);
            sendResponse({ isActive: item.isActive, fromCache: true, details: item.details });
          } else {
            console.log(`[Cache] MISS or STALE for ${CACHE_PREFIX + key}`);
            sendResponse({ isActive: null, fromCache: false });
          }
          return;
        }

        case "setCache": {
          const key = isString(message.key) ? message.key : "";
          if (!key) {
            sendResponse({ success: false, error: "Missing key" });
            return;
          }
          await writeCache(key, message.value || {});
          console.log(`[Cache] Stored ${CACHE_PREFIX + key}`, message.value);
          sendResponse({ success: true });
          return;
        }

        case "clearCache": {
          await clearCache();
          sendResponse({ success: true });
          return;
        }

        // Keep PAT private to background. Prefer UI to write it, but no public read.
        // If you need a setter from popup, keep it; but don't hand PAT to content scripts.
        case "setPAT": {
          await setLocal({ githubPAT: String(message.pat || "") });
          await clearCache();
          sendResponse({ success: true });
          return;
        }

        case "setConfig": {
          // Store unified config key used across popup/content/background
          await setLocal({ [CONFIG_KEY]: message.config || {} });
          sendResponse({ success: true });
          return;
        }

        case "getConfig": {
          const stored = (await getLocal([CONFIG_KEY]))[CONFIG_KEY] || {};
          sendResponse({ config: stored });
          return;
        }

        // NEW: main entry for content scripts to request a repo status
        case "fetchRepoStatus": {
          if (!isString(message.url)) {
            sendResponse({ ok: false, error: "Missing url" });
            return;
          }

          // 1) try cache
          const cacheKey = (() => {
            try {
              const u = new URL(message.url);
              return u.hostname + u.pathname;
            } catch {
              return "";
            }
          })();

          if (!cacheKey) {
            sendResponse({ ok: false, error: "Invalid URL" });
            return;
          }

          const cached = await readCache(cacheKey);
          if (cached) {
            sendResponse({ ok: true, result: { status: cached.isActive, details: cached.details } });
            return;
          }

          // 2) compute + store
          const rules = await loadActiveRules();
          try {
            const result = await fetchRepoStatusByUrl(message.url, rules);
            await writeCache(cacheKey, { isActive: result.status, details: result.details });
            sendResponse({ ok: true, result });
          } catch (err) {
            // Fail closed (inactive) and cache the failure shortly (normal TTL is fine)
            await writeCache(cacheKey, { isActive: false, details: { error: String(err) } });
            sendResponse({ ok: true, result: { status: false } });
          }
          return;
        }

        case "open_popup": {
          // open a popup-sized window with your page
          await chrome.windows.create({
            url: "popup.html",
            type: "popup",
            width: 600,
            height: 600,
          });
          sendResponse({ status: "Popup opened!" });
          return;
        }

        default:
          sendResponse({ ok: false, error: "Unknown action" });
          return;
      }
    } catch (e) {
      sendResponse({ ok: false, error: String(e) });
    }
  })();

  return true; // keep channel open for async responses
});
