var config;
var rate_limited = false
// ---------- Helpers ----------
async function isRepoActive(url) {
  const res = await new Promise(resolve => {
    chrome.runtime.sendMessage(
      { action: "fetchRepoStatus", url },
      (response) => resolve(response)
    );
  });
  if (!res || res.ok === false) {
    console.warn("[Repo check] background error", res?.error);
    return false; // fail closed
  }
}


async function getCacheFromBackground(key) {
  return new Promise(resolve => {
    chrome.runtime.sendMessage({ action: "getCache", key }, (response) => resolve(response));
  });
}

async function setCacheInBackground(key, value) {
  return new Promise(resolve => {
    chrome.runtime.sendMessage({ action: "setCache", key, value }, (response) => resolve(response));
  });
}

function getActiveConfigMetrics() {
  return Object.entries(config)
    .filter(([key, field]) => field.active && field.value !== undefined)
    .reduce((acc, [key, field]) => {
      acc[key] = field.value;
      return acc;
    }, {});
}

function isRepoUrl(url) {
  try {
    const { hostname, pathname } = new URL(url);
    const parts = pathname.split("/").filter(Boolean);

    const reservedPaths = new Set([
      "topics", "explore", "features", "issues", "pulls",
      "marketplace", "orgs", "enterprise", "settings",
      "sponsors", "login", "logout", "signup", "register",
      "notifications", "dashboard", "admin", "administrator",
      "help", "support", "docs", "api", "about", "contact",
      "security", "apps", "blog", "events", "community",
      "organizations", "repositories", "search", "trending",
      "gist", "gist.github", "releases", "archive", "new",
      "watching", "stars", "forks", "followers", "following",
      "milestones", "projects", "teams", "labels", "topics",
      "codespaces", "actions", "discussions", "pages"
    ]);

    switch (hostname) {
      case "github.com":
      case "gitlab.com":
        return parts.length >= 2 && !reservedPaths.has(parts[0]);

      case "codeberg.org":
        // Gitea-based, similar structure: owner/repo
        return parts.length >= 2 && !reservedPaths.has(parts[0]);

      case "bitbucket.org":
        // /workspace/repo
        return parts.length >= 2 && !reservedPaths.has(parts[0]);

      case "git.sr.ht":
        // Sourcehut: /~user/repo or /user/repo
        return (parts.length >= 2 || (parts.length >= 1 && parts[0].startsWith("~")));

      case "launchpad.net":
        // /project or /project/series
        return parts.length >= 1 && !reservedPaths.has(parts[0]);

      case "www.npmjs.com":
      case "npmjs.com":
        return parts[0] === "package" && parts.length >= 2;

      case "hub.docker.com":
        return parts[0] === "r" && parts.length >= 3;

      case "pypi.org":
        return parts[0] === "project" && parts.length >= 2;

      case "crates.io":
        return parts[0] === "crates" && parts.length >= 2;

      case "packagist.org":
        return parts[0] === "packages" && parts.length >= 3;

      default:
        return false;
    }
  } catch {
    return false;
  }
}

// ---------- Repo Activity Check ---------- 
  return res.result?.status; // true | false | "rate_limited" | "private"


  console.log(`[Repo check] Cache miss for ${url}`);
  let isActive = true;

  try {
    switch (hostname) {
      // -------------------- GITHUB --------------------
      case "github.com": {
        const [owner, repo] = parts;
        const githubPAT = await getPAT();
        const headers = {
          Accept: "application/vnd.github.v3+json",
          ...(githubPAT ? { Authorization: `token ${githubPAT}` } : {})
        };

        // COMMENTED OUT: const repoRes = await fetch(`https://api.github.com/repos/${owner}/${repo}`, { headers });
        const repoRes = await fetch(`https://api.github.com/repos/${owner}/${repo}`, { headers });
        if (repoRes.status === 403) {
          console.warn(`[Rate limited] GitHub API hit for ${owner}/${repo}`);
          await setCacheInBackground(key, { isActive: "rate_limited" });
          return "rate_limited";
        }
        if (!repoRes.ok) throw new Error(`GitHub API failed: ${repoRes.status}`);

        const repoData = await repoRes.json();
        if (repoData.private) {
          await setCacheInBackground(key, { isActive: "private" });
          return "private";
        }

        // Push activity
        const lastPush = new Date(repoData.pushed_at);
        const cutoff = new Date();
        cutoff.setDate(cutoff.getDate() - (activeMetrics.max_repo_update_time ?? 180));
        if (lastPush < cutoff) isActive = false;

        // Optionally add PR / issues / releases checks (your existing code already does)
        break;
      }

      // -------------------- CODEBERG (Gitea) --------------------
      case "codeberg.org": {
        const [owner, repo] = parts;
        // COMMENTED OUT: const res = await fetch(`https://codeberg.org/api/v1/repos/${owner}/${repo}`);
        // if (!res.ok) throw new Error(`Codeberg API failed: ${res.status}`);
        // const data = await res.json();

        // const lastActivity = new Date(data.updated_at || data.pushed_at || data.created_at);
        // const cutoff = new Date();
        // cutoff.setDate(cutoff.getDate() - (activeMetrics.max_repo_update_time ?? 180));
        // isActive = lastActivity >= cutoff;
        break;
      }

      // -------------------- GITLAB --------------------
      case "gitlab.com": {
        const [owner, repo] = parts;
        const projectPath = encodeURIComponent(`${owner}/${repo}`);
        // COMMENTED OUT: const res = await fetch(`https://gitlab.com/api/v4/projects/${projectPath}`);
        if (!res.ok) throw new Error(`GitLab API failed: ${res.status}`);
        const data = await res.json();

        const lastActivity = new Date(data.last_activity_at);
        const cutoff = new Date();
        cutoff.setDate(cutoff.getDate() - (activeMetrics.max_repo_update_time ?? 180));
        isActive = lastActivity >= cutoff;
        break;
      }

      // -------------------- BITBUCKET --------------------
      case "bitbucket.org": {
        const [workspace, repo] = parts;
        // COMMENTED OUT: const res = await fetch(`https://api.bitbucket.org/2.0/repositories/${workspace}/${repo}`);
        if (!res.ok) throw new Error(`Bitbucket API failed: ${res.status}`);
        const data = await res.json();

        const lastActivity = new Date(data.updated_on || data.created_on);
        const cutoff = new Date();
        cutoff.setDate(cutoff.getDate() - (activeMetrics.max_repo_update_time ?? 180));
        isActive = lastActivity >= cutoff;
        break;
      }

      // -------------------- SOURCEHUT (git.sr.ht) --------------------
      case "git.sr.ht": {
        // No easy API: scrape the page for <time datetime="...">
        // COMMENTED OUT: const res = await fetch(url);
        if (res.ok) {
          const text = await res.text();
          const match = text.match(/<time[^>]+datetime="([^"]+)"/);
          if (match) {
            const last = new Date(match[1]);
            const cutoff = new Date();
            cutoff.setDate(cutoff.getDate() - (activeMetrics.max_repo_update_time ?? 180));
            isActive = last >= cutoff;
          }
        }
        break;
      }

      // -------------------- LAUNCHPAD --------------------
      case "launchpad.net": {
        // Similar fallback: scrape for time elements
        // COMMENTED OUT: const res = await fetch(url);
        if (res.ok) {
          const text = await res.text();
          const match = text.match(/<time[^>]+datetime="([^"]+)"/);
          if (match) {
            const last = new Date(match[1]);
            const cutoff = new Date();
            cutoff.setDate(cutoff.getDate() - (activeMetrics.max_repo_update_time ?? 180));
            isActive = last >= cutoff;
          }
        }
        break;
      }

      // -------------------- NPM --------------------
      case "www.npmjs.com":
      case "npmjs.com": {
        // e.g. https://www.npmjs.com/package/react
        const pkg = parts.slice(1).join("/");
        // COMMENTED OUT: const res = await fetch(`https://registry.npmjs.org/${pkg}`);
        if (res.ok) {
          const data = await res.json();
          const last = new Date(data.time?.modified || data.time?.created);
          const cutoff = new Date();
          cutoff.setDate(cutoff.getDate() - (activeMetrics.max_repo_update_time ?? 180));
          isActive = last >= cutoff;
        }
        break;
      }

      // -------------------- PYPI --------------------
      case "pypi.org": {
        // e.g. https://pypi.org/project/requests/
        const pkg = parts[1];
        // COMMENTED OUT: const res = await fetch(`https://pypi.org/pypi/${pkg}/json`);
        if (res.ok) {
          const data = await res.json();
          const last = new Date(data.info?.upload_time_iso_8601 || data.releases?.[0]?.upload_time);
          const cutoff = new Date();
          cutoff.setDate(cutoff.getDate() - (activeMetrics.max_repo_update_time ?? 180));
          isActive = last >= cutoff;
        }
        break;
      }

      // -------------------- CRATES.IO --------------------
      case "crates.io": {
        const crate = parts[1];
        // COMMENTED OUT: const res = await fetch(`https://crates.io/api/v1/crates/${crate}`);
        if (res.ok) {
          const data = await res.json();
          const last = new Date(data.crate?.updated_at);
          const cutoff = new Date();
          cutoff.setDate(cutoff.getDate() - (activeMetrics.max_repo_update_time ?? 180));
          isActive = last >= cutoff;
        }
        break;
      }

      // -------------------- PACKAGIST --------------------
      case "packagist.org": {
        const vendor = parts[1];
        const pkg = parts[2];
        // COMMENTED OUT: const res = await fetch(`https://packagist.org/packages/${vendor}/${pkg}.json`);
        if (res.ok) {
          const data = await res.json();
          const last = new Date(data.package?.time);
          const cutoff = new Date();
          cutoff.setDate(cutoff.getDate() - (activeMetrics.max_repo_update_time ?? 180));
          isActive = last >= cutoff;
        }
        break;
      }

      // -------------------- DOCKER HUB --------------------
      case "hub.docker.com": {
        const [_, namespace, repo] = parts; // /r/namespace/repo
        // COMMENTED OUT: const res = await fetch(`https://hub.docker.com/v2/repositories/${namespace}/${repo}/`);
        if (res.ok) {
          const data = await res.json();
          const last = new Date(data.last_updated || data.last_pushed);
          const cutoff = new Date();
          cutoff.setDate(cutoff.getDate() - (activeMetrics.max_repo_update_time ?? 180));
          isActive = last >= cutoff;
        }
        break;
      }

      // -------------------- FALLBACK --------------------
      default:
        console.log(`[Repo check] No integration for ${hostname}`);
        isActive = true;
        break;
    }

    await setCacheInBackground(key, { isActive });
    console.log(`[Result] ${url} isActive=${isActive}`);
    return isActive;

  } catch (e) {
    console.warn("[Repo check failed]", url, e);
    await setCacheInBackground(key, { isActive: false });
    return false;
  }
}


// ---------- Banner ----------
function createBanner(status) {
  const isRateLimited = status === "rate_limited";
  const isPrivate = status === "private";
  const isActive = status === true;
  const isInactive = status === false;

  const banner = document.createElement("div");
  banner.className = "my-banner";

  Object.assign(banner.style, {
    background: isRateLimited ? "#fff4e5" :
                isPrivate ? "#f0f0f0" :
                isActive ? "#e6ffe6" : "#ffe6e6",
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    padding: "0.75em 1.25em",
    borderRadius: "12px",
    boxShadow: "0 4px 12px rgba(0,0,0,0.1)",
    fontFamily: "system-ui, sans-serif",
    margin: ".5em 0",
    position: "relative",
    transition: "all 0.3s ease",
  });

  const textContainer = document.createElement("div");
  textContainer.style.display = "flex";
  textContainer.style.flexDirection = "column";
  textContainer.style.flex = "1";

  let mainMessage = "";
  let bgColor = "";
  let emoji = "";

  if (isRateLimited) {
    emoji = "⏳";
    mainMessage = "Rate limit hit — Results temporarily inactive";
    bgColor = "#f57c00";
  } else if (isPrivate) {
    emoji = "🔒";
    mainMessage = "Private Repository";
    bgColor = "#555";
  } else if (isActive) {
    emoji = config.emoji_active.active ? config.emoji_active.value : "";
    mainMessage = `${emoji} Repo is Active !`;
    bgColor = "#1a8917";
  } else if (isInactive) {
    emoji = config.emoji_inactive.active ? config.emoji_inactive.value : "";
    mainMessage = `${emoji} Repo is InActive`;
    bgColor = "#d32f2f";
  }

  const mainText = document.createElement("span");
  mainText.textContent = mainMessage;
  Object.assign(mainText.style, {
    color: "white",
    fontWeight: "600",
    fontSize: "1rem",
    padding: "0.5em 1em",
    backgroundColor: bgColor,
    borderRadius: "9999px",
    textAlign: "center",
    transition: "background-color 0.3s ease, transform 0.2s ease",
  });

  const configLink = document.createElement("a");
  configLink.href = "#";
  configLink.textContent = isRateLimited
    ? "(GitHub API limit reached Add your Personal Access Token)"
    : "(According to your Configuration)";
  Object.assign(configLink.style, {
    fontSize: "0.8rem",
    textDecoration: "underline",
    cursor: "pointer",
    marginTop: "0.25em",
    alignSelf: "center",
  });
  configLink.onclick = e => {
    e.preventDefault();
    chrome.runtime.sendMessage({ action: "open_popup" });
  };

  const closeBtn = document.createElement("button");
  closeBtn.textContent = "✖";
  Object.assign(closeBtn.style, {
    background: "transparent",
    border: "none",
    color: "#444",
    fontSize: "1.25rem",
    cursor: "pointer",
    marginLeft: "1em",
    transition: "color 0.2s ease",
  });
  closeBtn.onclick = () => banner.remove();

  textContainer.appendChild(mainText);
  textContainer.appendChild(configLink);
  banner.appendChild(textContainer);
  banner.appendChild(closeBtn);
  document.body.prepend(banner);
}

async function markRepoLinks() {
  // Top-level document
  await markLinksInDocument(document);

  // Then check iframes
  const iframes = document.querySelectorAll("iframe");
  for (const iframe of iframes) {
    try {
      
      const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
      if (iframeDoc) {
        await markLinksInDocument(iframeDoc);
      }
    } catch (err) {
      // Cross-origin iframe — can't access
      console.warn("Cannot access iframe:", iframe?.src, err);
    }
  }
}

async function markLinksInDocument(doc) {
  const links = doc.querySelectorAll("a");
  for (const link of links) {
    if (isRepoUrl(link.href) && !link.dataset.repoChecked) {
      link.dataset.repoChecked = "true";
      const status = await isRepoActive(link.href);

      const mark = doc.createElement("span");
      mark.textContent =
        status === "private" ? "🔒 " :
        status === "rate_limited" ? "⏳ " :
        status === true ? (config.emoji_active.active ? `${config.emoji_active.value} ` : "") :
        status === false ? (config.emoji_inactive.active ? `${config.emoji_inactive.value} ` : "") :
        "";

      mark.style.color =
        status === "private" ? "#555" :
        status === "rate_limited" ? "#f57c00" :
        status === true ? "green" :
        "red";

      link.prepend(mark);
    }
  }
}

function looksLikeGithubRepoUrl(url) {
  try {
    const { hostname, pathname } = new URL(url);
    if (hostname !== "github.com") return false;
    const parts = pathname.split("/").filter(Boolean);
    return parts.length >= 2;
  } catch {
    return false;
  }
}

function isGithubRepoPageNow() {
  // Meta tag check
  if (document.querySelector('meta[name="octolytics-dimension-repository_nwo"]')) return true;

  // AppHeader context label (very reliable)
  if (document.querySelector('.AppHeader-context-item-label')) return true;

  // Tabs bar (Code / Issues / PRs)
  if (document.querySelector('.UnderlineNav')) return true;

  return false;
}

async function waitForGithubRepoIndicators(timeout = 3000) {
  const start = Date.now();
  while (Date.now() - start < timeout) {
    if (isGithubRepoPageNow()) return true;
    await new Promise(r => setTimeout(r, 100));
  }
  return false;
}

(async () => {
  config = await new Promise(resolve => {
    chrome.storage.local.get(["repoCheckerConfig"], ({ repoCheckerConfig }) => {
      resolve(repoCheckerConfig || defaultConfig);
    });
  });

  const currentUrl = window.location.href;
  let onRepoPage = isRepoUrl(currentUrl);

  if (looksLikeGithubRepoUrl(currentUrl)) {
    const confirmed = await waitForGithubRepoIndicators();
    if (confirmed) {
      console.log("[Repo detection] Confirmed GitHub repo page");
      onRepoPage = true;
    } else {
      console.log("[Repo detection] No repo indicators found, not a repo page");
      onRepoPage = false;
    }
  }

  if (onRepoPage) {
    const status = await isRepoActive(currentUrl);
    createBanner(status);
  } else {
    markRepoLinks();
    const observer = new MutationObserver(markRepoLinks);
    observer.observe(document.body, { childList: true, subtree: true });
  }
})();

/*

const githubNavObserver = new MutationObserver(async () => {
  if (looksLikeGithubRepoUrl(window.location.href) && isGithubRepoPageNow()) {
    const existingBanner = document.querySelector(".my-banner");
    if (existingBanner) existingBanner.remove();

    console.log("[Repo detection] PJAX navigation detected — injecting fresh banner");
    const status = await isRepoActive(window.location.href);
    createBanner(status);
  }
});


githubNavObserver.observe(document.body, { childList: true, subtree: true });
*/
